set runtimepath+=~/.vim/bundle/neobundle.vim
call neobundle#begin(expand('~/.vim/bundle'))

NeoBundleFetch 'Shougo/neobundle.vim'

NeoBundle("tomtom/tcomment_vim") " 一括コメントアウト
NeoBundle('bronson/vim-trailing-whitespace')  " 全角スペースをハイライト
NeoBundle('tpope/vim-surround')  " 括弧などのブロック文字を簡単に変更
NeoBundle('cohama/lexima.vim')  " 自動でカッコなどを閉じる
NeoBundle('kana/vim-textobj-user') " textobj設定
NeoBundle('cocopon/vaffle.vim') " filer

NeoBundle('scrooloose/nerdtree') " file tree
nnoremap <leader>f :NERDTreeToggle<CR>

function! s:meet_neocomplete_requirements()
    return has('lua') && (v:version > 703 || (v:version == 703 && has('patch885')))
endfunction

if s:meet_neocomplete_requirements()
    NeoBundle 'Shougo/neocomplete.vim'
    let g:acp_enableAtStartup = 0
    let g:neocomplete#enable_at_startup = 1
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#sources#syntax#min_keyword_length = 3

    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
        return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
    endfunction

    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"
else
    NeoBundle 'Shougo/neocomplcache.vim'
    let g:acp_enableAtStartup = 0
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_enable_smart_case = 1
    let g:neocomplcache_min_syntax_length = 3

    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
        return neocomplcache#smart_close_popup() . "\<CR>"
    endfunction
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplcache#close_popup()
    inoremap <expr><C-e>  neocomplcache#cancel_popup()
    inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"
endif

NeoBundle('terryma/vim-expand-region') " 範囲選択をショートカットで
vmap v <Plug>(expand_region_expand)
vmap <C-v> <Plug>(expand_region_shrink)

NeoBundle('t9md/vim-choosewin')  " ウィンドウ選択
nmap - <Plug>(choosewin)
let g:choosewin_label = 'fjsldka;'

set runtimepath+=~/.vim/bundle/jellybeans.vim
NeoBundle('nanotech/jellybeans.vim')
colorscheme jellybeans

NeoBundle('easymotion/vim-easymotion') " 画面内の任意の場所にジャンプ
let g:EasyMotion_keys = 'fjdkslaureiwoqpvncm' " ジャンプ用のタグに使う文字の優先順位
let g:EasyMotion_startofline = 0 " keep cursor column when JK motion
nmap <leader><leader> <Plug>(easymotion-s2)

" ステータスライン関連（画面下）
set noshowmode
NeoBundle('itchyny/lightline.vim')
let g:lightline = {
            \ 'colorscheme': 'wombat',
            \ 'active': {
            \   'left': [
            \     ['mode', 'paste'],
            \     ['filename'],
            \   ],
            \   'right': [
            \     ['lineinfo'], ['percent'],
            \     ['charcode', 'fileformat', 'fileencoding', 'filetype'],
            \   ]
            \ },
            \ 'component_function': {
            \   'mode': 'MyMode',
            \   'filename': 'MyFileName',
            \   'fileformat': 'MyFileFormat',
            \   'fileencoding': 'MyFileEncoding',
            \   'filetype': 'MyFileType',
            \   'charcode': 'MyCharCode',
            \ },
            \ 'separator': {'left': '>>', 'right': '|'},
            \ 'subseparator': {'left': '|', 'right': '|'}
            \ }

function! MyModified()
    return &ft =~ 'help\|terminal' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadOnly()
    return &ft !~? 'help\|vimfiler' && &ro ? '|' : ''
endfunction

function! MyFileName()
    let fname = expand('%p:t')
    return  &ft == 
                \ ('' != MyReadOnly() ? MyReadOnly() . ' ' : '') .
                \ ('' != fname ? fname : '[No Name]') .
                \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFileFormat()
    return winwidth('.') > 70 ? &fileformat : ''
endfunction

function! MyFileType()
    return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileEncoding()
    return winwidth('.') > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
    return winwidth('.') > 60 ? lightline#mode() : ''
endfunction

function! MyCharCode()
    if winwidth('.') <= 70
        return ''
    endif

    " Get the output of :ascii
    redir => ascii
    silent! ascii
    redir END

    if match(ascii, 'NUL') != -1
        return 'NUL'
    endif

    " Zero pad hex values
    let nrformat = '0x%02x'

    let encoding = (&fenc == '' ? &enc : &fenc)

    if encoding == 'utf-8'
        " Zero pad with 4 zeroes in unicode files
        let nrformat = '0x%04x'
    endif

    " Get the character and the numeric value from the return value of :ascii
    " This matches the two first pieces of the return value, e.g.
    " "<F>  70" => char: 'F', nr: '70'
    let [str, char, nr; rest] = matchlist(ascii, '\v\<(.{-1,})\>\s*([0-9]+)')

    " Format the numeric value
    let nr = printf(nrformat, nr)

    return "'". char ."' ". nr
endfunction

call neobundle#end()

NeoBundleCheck

