#! /bin/bash

# cd+ls
cdls() {
  if ! builtin cd 2>/dev/null $@; then
    echo "cannot cd: $@$reset_color"
    return
  fi
  if [ "$?" -eq 0 ]; then
    lscdmax=40
    nfiles=$(/bin/ls|wc -l)
    if [ $nfiles -eq 0 ]; then
      if [ "$(/bin/ls -A|wc -l)" -eq 0 ]; then
        echo "no files in: $(pwd)$reset_color"
      else
        echo "only hidden files in: $(pwd)$reset_color"
        ls -A --color=auto
      fi
    elif [ $lscdmax -ge $nfiles ]; then
      ls -F --color=auto
    else
      echo "$nfiles files in: $(pwd)$reset_color"
    fi
  fi
}

# colorize less
exists /usr/bin/lesspipe && eval "$(SHELL=/bin/sh lesspipe)"

# aliases
alias a='alias'
alias mmm='man bash | grep "^\s*\${.*}$" | tr -d " "'
alias cd='cdls'
alias ls='ls -F --color=auto'
alias ll='ls -Flh --color=auto'
alias la='ls -Flha --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
alias diff='colordiff'
alias mv='mv -i'
alias rm='rm -i'
alias cp='cp -i'
alias q='exit'
alias quit='exit'
alias e='nvim ~/.bashrc'
alias E='nvim ~/.vimrc'
alias u='. ~/.bashrc'
alias j='cd -'
alias h='cd $(git rev-parse --show-toplevel 2>/dev/null)'
alias H='cd ~'
alias ..='cd ..'
alias .2='cd ../..'
alias .3='cd ../../..'
alias .4='cd ../../../..'
alias g='git'
alias t='mkdir -p ~/t && cd ~/t'
exists batcat && alias bat='batcat'
exists fdfind && alias fd='fdfind'
exists nvim && alias v='nvim'
exists nvim && alias agit='nvim +Agit'
exists w3m && alias w3m='w3m -O ja_JP.UTF-8'
exists tmux && alias tmux="tmux -2"
exists docker && alias d='docker'
exists docker-compose && alias dc='docker-compose'
# tcpdump -nn -p -i eth0 tcp dst port 80 -tttt -vvv
# tcpdump -i eth0 '(tcp[tcpflags] & tcp-syn)' != 0 and '(tcp[tcpflags] & tcp-ack) ==0'
# ss -ntulp --unix

if exists kubectl ; then
    alias k='kubectl'
    # Pod
    alias kgp='kubectl get po'
    alias kdp='kubectl describe po'
    alias kl='kubectl logs'
    alias kx='kubectl exec -it'
    alias kxx='kubectl exec'
    # Service
    alias kgs='kubectl get svc'
    alias kds='kubectl describe svc'
    # Deployment
    alias kgd='kubectl get deploy'
    alias kdd='kubectl describe deployment'

    complete -F __start_kubectl k
    source <(kubectl completion bash)
    export PATH="${KREW_ROOT:-$HOME/.krew}/bin:$PATH"
fi

# fzf
[ -f ~/.fzf.bash ] && . ~/.fzf.bash
export FZF_DEFAULT_OPTS='--height 90% --reverse --border'
export FZF_COMPLETION_TRIGGER='jj'

_fzf_compgen_path() {
      fd --hidden --follow --exclude ".git" . "$1"
}

_fzf_compgen_dir() {
      fd --type d --hidden --follow --exclude ".git" . "$1"
}

_fzf_comprun() {
    local command=$1
    shift

    case "$command" in
        cd)           fzf "$@" --preview 'tree -C {} | head -200' ;;
        export|unset) fzf "$@" --preview "eval 'echo \$'{}" ;;
        ssh)          fzf "$@" --preview 'dig {}' ;;
        *)            fzf "$@" ;;
    esac
}

__fzf_ghq__() {
    name=$(ghq list -p | fzf --preview 'tree -C {} | head -200')
    if [ ! -z "${name}" ]; then
        history -s "cd $name"
        \cd $name
    fi
}

__fzf_git_cd__() {
    toplevel=$(git rev-parse --show-toplevel 2>/dev/null)
    if [ -z "${toplevel}" ]; then
        echo "error: this is not a git repository"
        return 1
    fi

    # git fd is defined in .gitconfig
    selected=$(git fd --type d | fzf -m --preview 'tree -C '${toplevel}'/{} | head -400')
    if [ ! -z "${selected}" ]; then
        history -s "cd ${toplevel}/${selected}"
        cd ${toplevel}/${selected}
    fi
}

gcd() {
    __fzf_git_cd__
}

__fzf_git_file__() {
    toplevel=$(git rev-parse --show-toplevel 2>/dev/null)
    if [ -z "${toplevel}" ]; then
        echo "error: this is not a git repository"
        return 1
    fi

    selected=$(git fd --type f -H | grep -v "^\.git/"| fzf -m --preview 'batcat --style=numbers --color=always --line-range :400 '${toplevel}'/{}')
    if [ ! -z "${selected}" ]; then
        history -s "${EDITOR} ${toplevel}/${selected}"
        ${EDITOR} ${toplevel}/${selected}
    fi
}

__fzf_git_branch__() {
    toplevel=$(git rev-parse --show-toplevel 2>/dev/null)
    if [ -z "${toplevel}" ]; then
        echo "error: this is not a git repository"
        return 1
    fi

    branches=$(env IFS='\n' git branch -a --sort='-committerdate' --format='[%(committerdate:short)] %(refname:short) %(authorname)')
    # git l is defined in .gitconfig
    selected=$(echo "$branches" | fzf -m --preview "eval 'git show \$(echo '{}' | cut -d\" \" -f2) | batcat --color=always --line-range :400'")
    if [ ! -z "${selected}" ]; then
        branch=$(echo ${selected} | cut -d" " -f2)
        history -s "git checkout ${branch}"
        git checkout ${branch}
    fi
}

bind -r "\C-g"
bind -r "\C-j"
bind -r "\C-o"
bind -x '"\C-g": __fzf_ghq__'
bind -x '"\C-o": __fzf_git_file__'
bind -x '"\C-j": __fzf_git_branch__'

